# CSPT19 Sprint 3 - Data Structures and Algorithms II

## Module 3 - Graphs I

- [Lecture with Sean](https://youtu.be/oK9mN30jLMI)

- [Lecture with Mari](https://youtu.be/FnSfMozvM9U)

- [Mari's Slides](https://docs.google.com/presentation/d/1_oHh1MLm5xKNVAc2Qs28WgL2XCvDZ0S8oyFd6GPcijk/edit#slide=id.gaf7a053ae0_0_4)

- [Mari's Solution Code](https://hackmd.io/@sIQnCbQ0T56A3KLAiNrlhQ/B1fDJ9MId)

- [Previous Module Project Solutions](https://hackmd.io/@sIQnCbQ0T56A3KLAiNrlhQ/BkGqQfdWd)

## Intro to Graphs

- A very versatile data structure that allows you to represent relationships between data
    - Social network, flight schedule, word relationships, etc.
    
Graphs have "edges" that are essentially their pointers.

## Components of a Graph

- **Vertex** - also called nodes

- **Edge** - connects a pair of nodes
    - There are two types of edges:
        - *Unidirectional* - Path from A to B but there’s no path from B to A
        - *Bidirectional* - A is friends with B, then B is friends with A

- **Weight** - used to represent a value associated with the edge (usually a cost)

## Examples of Graphs
- **Social Networks**
    - Each node is a user, edges are friendships between nodes

    - Edges can also be to which groups you are a part of

- **Transportation Systems** (BART, Maps, etc.)
    - Each `node` is a `location`, each `edge` is a `route` to another one. A weight can represent time to get there

- **The Internet!**
    - Each `page` can be represented as a `node`, a `directed edge` is a `link` to another web page
    
## Graph Propeerties

- A graph can have multiple properties

- Knowing these different properties are important, so you can build/solve graph problems!

## Directed -vs- Undirected

- A graph can be either `directed` or `undirected`
- **Directed** - An `edge` from `A to B` `doesn’t` mean there’s an edge from `B to A`
- **Undirected** - An `edge` from `A to B` means `there’s also` an edge from `B to A`

## Cyclic -vs- Acyclic

- Applies to **directed** graphs
- **Cyclic** - there’s `at least one path` from a `node back to itself`
- **Acyclic** - there are `no paths` such that no node can be traversed back to itself
- A tree is a directed acyclic graph!

## Dense -vs- Sparse

- A graph can be `sparse/dense` or anything in between
- **Dense** - contains close to the `maximum edges` possible
- **Sparse** - contains close to the `minimum edges` possible

## Weighted -vs- Unweighted

- A graph can either be `weighted` or `unweighted`
- Weight determines a value associated with an edge (usually a cost)
- **Weighted** - Each edge has an associated value
- **Unweighted** - Each edge has no associated value

## Adjacency List

- Use a dictionary with sets to represent the edges of a particular vertex to other neighboring vertices
- adjacencyList[i] is a set of all the edges to its neighbors for vertex i

```
class Graph:
    def __init__(self):
        self.graph = {}
        
    def __repr__(self):
        return str(self.graph)
        
    def add_node(self, value):
        if value not in self.graph:
            self.graph[value] = set()
        
    def remove_node(self, value):
        if value in self.graph:
            self.graph.pop(value)
            for others in self.graph:
                if value in self.graph[others]:
                    self.graph[others].remove(value)
    
    def add_edge(self, from, to):
        self.graph[from].add(to)
    
    def remove_edge(self, from, to):
        self.graph[from].remove[to]
    
    def edge_exists(self, from, to):
        return to in self.graph[from]
    
my_graph = Graph()
my_graph.add_node(1)
my_graph.add_node(2)
my_graph.add_node(3)
my_graph.add_node(4)
my_graph.add_edge(1, 2)
my_graph.add_edge(1, 3)
my_graph.add_edge(2, 4)
my_graph.add_edge(3, 4)
my_graph.add_edge(4, 1)
my_graph.remove_edge()
print(my_graph.edge_exists(4, 1))
print(my_graph.edge_exists(3, 1))
my_graph.remove_node(4)
print(my_graph)
```

## Adjacency List Runtime/Space Complexity

- Space: `O(vertices^2)`
    - Imagine a dense graph
- Add vertex: `O(1)`
- Remove vertex: `O(vertices)`
- Add edge: `O(1)`
- Remove edge: `O(1)`
- Find edge: `O(1)`
- Get all edges: `O(1)`

## Adjacency Matrix

- Use a matrix to represent whether or not there exists an edge between two vertices
- matrix[i][j] is True if there exists an edge from vertex i to vertex j

## Adjacency Matrix Runtime/Space Complexities

- Space: O(vertices2)
    - Even in a sparse graph, but good for dense graphs b/c lists are space efficient
- Add vertex: O(vertices2)
- Remove vertex: O(vertices2)
- Add edge: O(1)
- Remove edge: O(1)
- Find edge: O(1)
- Get all edges: O(vertices)

## Adjacency Matrix -vs- Adjacency Lists

|  | Space | Add Vertices | Remove Vertices | Add Edge | Remove Edge | Find Edge | Get All Edges |
| --- | --- | --- | --- | --- | --- | --- | --- |
| Adj. Matrix | O(V2) | O(V2) | O(V2) | O(1) | O(1) | O(1) | O(V) |
| Adj. List | O(V2) | O(1) | O(1) | O(1) | O(1) | O(1) | O(1) |

- The best representation mainly depends on whether or not the graph is sparse/dense and what you’re optimizing for (space/runtime)
- If you’re optimizing for space, representing dense graphs are probably better with adj. matrix because lists are very space efficient in comparison to dictionaries/sets
- You’ll probably deal with more adjacency lists

## Graph Traversals
- There are two primary ways to traverse a graph: `Depth-first` and `Breadth-first`
- Traversal vs. Search
    - In a search, you stop once you find the node you’re searching for
    - In a traversal, you traverse the entire graph
    
- Depth-First Traversal:
    - Traverse the graph in a depth-ward motion using a stack/recursion
    - Pseudocode:
        ```
        function dfs_iterative(G, v)
            s = stack
            s.push(v)
            
            while s is not empty:
                v = s.pop()
                if v is not labeled as discovered:
                    label v as discovered
                    for all edges from v to w in g.adjacent_edges(v):
                        s.push(w)
        ```
        ```
    from collections import deque
    
    def dft(graph, start_node):
        # Impliment a stack using a double ended queue
        s = deque()
        # Append the starting node to stack
        s.append(start_node)
        # Create a visited list to prevent from going back to a node already visited
        visited = set()
        
        # While there is something still in the stack
        while len(s) > 0:
            # Pop the last value off the stack and make that the current node
            curr = s.pop()
            
            # If the current node is not in the visited list yet
            if curr not in visited:
                # Add the current node to the visited list
                visitied.add(curr)
                # Print the current node
                print(curr)
                
                # Iterate through the graph at current node to get the neighbors for the current node
                for neighbors in graph[curr]:
                    # Append the neighbors to the top of the stack
                    s.append(neighbors)
    ```

    - Recursive DFT pseudocode:
        ```
        function dft_rec(g, v)
            label v as discovered
            for all directed edges from v to w that are in g.adjacent_edges(v)
                if vertex w is not labeled as discovered
                    recursively call dft_rec(g, w)
        ```
  
- Breadth-First Traversal
    - Traverse the graph in a breadth-ward motion using a queue
    - Very useful for finding shortest path from node to node
        ```
        
        ```
        ```
        
        ```



