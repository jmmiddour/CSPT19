# CSPT19 Sprint 1 - Computer Science Fundamentals

## [Objective 01 - Perform basic dictionary operations](https://lambdaschool.instructure.com/courses/932/pages/objective-01-perform-basic-dictionary-operations?module_item_id=557560)

<p><a href="https://lambdaschool.instructure.com/courses/932/pages/objective-01-perform-basic-dictionary-operations?module_item_id=557560&amp;wvideo=1p8vfyh1oj"><img src="https://embed-fastly.wistia.com/deliveries/51324278d0f441d34b39f24265ad9287.jpg?image_play_button_size=2x&amp;image_crop_resized=960x540&amp;image_play_button=1&amp;image_play_button_color=2d539de0" width="400" height="225" style="width: 400px; height: 225px;"></a></p><p><a href="https://lambdaschool.instructure.com/courses/932/pages/objective-01-perform-basic-dictionary-operations?module_item_id=557560&amp;wvideo=1p8vfyh1oj">Computer Science - Basic Dictionary Operations - Lambda School</a></p>

### Overview
A dictionary is like a list, but instead of accessing values with an index, you access values with a "key". A "key" can be any type of object (`string`, `number`, `list`, `etc.`). Also, unlike lists, dictionaries do not have an order.

### Follow Along
Let's use a dictionary to create a collection that maps `first names` as `keys` (strings) to `phone numbers` as `values`.

```
phonebook = {} # creates an empty dictionary
phonebook["Abe"] = 4569874321
phonebook["Bill"] = 7659803241
phonebook["Barry"] = 6573214789

print(phonebook)
output ---> {'Abe': 4569874321, 'Bill': 7659803241, 'Barry': 6573214789}
```

Instead of adding one key-value pair at a time, we can initialize the dictionary to have the same values.

```
phonebook = {
    "Abe": 4569874321,
    "Bill": 7659803241,
    "Barry": 6573214789
}

print(phonebook)
output ---> {'Abe': 4569874321, 'Bill': 7659803241, 'Barry': 6573214789}
```

We can iterate over a dictionary as we iterated over a list. We can use the `items()` method, which returns a `tuple` with the `key` and `value` for `each item` in the dictionary.

```
for name, number in phonebook.items():
    print("Name: %s, Number: %s" % (name, number))

OUTPUT:
    Name: Abe, Number: 4569874321
    Name: Bill, Number: 7659803241
    Name: Barry, Number: 6573214789
```

To `remove` a `key-value pair` from a dictionary, you need to use the `del` keyword or use the `pop()` method available on dictionary objects. The difference is `pop()` deletes the item from the dictionary and `returns the value`. When you use the `del` keyword, you've written a statement that `doesn't evaluate to anything`.

```
phonebook = {
    "Abe": 4569874321,
    "Bill": 7659803241,
    "Barry": 6573214789
}

del phonebook["Abe"]

print(phonebook.pop("Bill"))
output ---> 7659803241
```

### Challenge
```
"""
Add "Herb" to the phonebook with the number 7653420789.
Remove "Bill" from the phonebook.
"""
phonebook = {
    "Abe": 4569874321,
    "Bill": 7659803241,
    "Barry": 6573214789,
    "Herb": 7653420789
}

del phonebook['Bill']

# Should print Herb is in the phonebook.
if "Herb" in phonebook:
    print("Herb is in the phonebook.")

# Should print Bill is not in the phonebook.
if "Bill" not in phonebook:
    print("Bill is not in the phonebook.")
```

### Additional Resources
- [w3schools - Python Dictionary](https://www.w3schools.com/python/python_dictionaries.asp)
- [Python Docs - Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)

## [Objective 02 - Recognize mutable and immutable objects](https://lambdaschool.instructure.com/courses/932/pages/objective-02-recognize-mutable-and-immutable-objects?module_item_id=557564)

[Computer Science - Mutability - YouTube](https://youtu.be/zPM_qXV3BwM)

### Overview
In Python, everything is an object.

```
a = 1
b = "hello"
c = [1,2,3]

isinstance(a, object)
output ---> True

isinstance(b, object)
output ---> True

isinstance(c, object)
output ---> True
```

Additionally, all objects in Python have three things:

1. Identity
2. Type
3. Value

```
a = 1
# Identity
id(a)
output ---> 4483164816

# Type
type(a)
output ---> <class 'int'>

# Value
a
output ---> 1
```

### Follow Along
#### Identity
An object's **identity** can never change once it has been created. You can think of an object's identity as its `specific address in memory`. In the code above, `a = 1` created a new object in memory whose identity is represented by the integer `4483164816`.

Python has an `is` operator that allows you to compare two object's identities.

```
a = 1
b = 2

a is b
output ---> False

b = a

a is b
output ---> True
```

In the code above, we first assign `1` to the variable `a`. Then, we assign `2` to the variable `b`. These are two different objects in memory and thus have different identities. We verify that they are different by using the `is` operator, which returns `False`. The line `b = a` assigns the variable `b` the object that the variable `a` is pointed to. Now, both `a` and `b` are referencing the same object in memory. We can use the `id()` function to verify that this is the case as well:

```
id(a)
output ---> 4483164816

id(b)
output ---> 4483164816
```

#### Type
The **type** of an object determines what are its possible values and what operations that object supports. The `type()` function will return what type an object is:

```
a = 'Hello'
type(a)
output ---> <class 'str'>

b = 100
type(b)
output ---> <class 'int'>

c = True
type(c)
output ---> <class 'bool'>
```

Just like an object's identity, once an object is created, its identity can never change. It's an object's type that determines whether an object is **mutable** or **immutable**.

#### Value
The value of some objects can be changed after they are created. The value of some objects cannot be changed after they are created. `If the object's value can be changed`, that object is considered to be `mutable` (changeable). `If the object's value cannot be changed`, that object is considered to be `immutable` (unchangeable).

#### Mutable Objects
A mutable object is an object whose value can be changed after it is created. The word mutable is defined as:

> liable to change

The following types of objects are **mutable**:

- list
- set
- dict
- byte array
- instances of user-defined classes

Let's look at a few examples in code:

#### Lists
```
my_list = ['laughter', 'happiness', 'love']
type(my_list)
output ---> <class 'list'>

my_list[2] = 'joy'
my_list.append('excellent')
my_list
output ---> ['laughter', 'happiness', 'joy', 'excellent'
```

In the first line, we create a list object with three elements and assign it to the variable `my_list`. Then, because `lists are mutable`, we change `'love'` at `index 2` to be `'joy'` instead. We also can grow our list by `appending` a new element to the list.

#### Sets
```
my_set = {'laughter', 'happiness', 'love'}
type(my_set)
output ---> <class 'set'>

my_set.add('happy')
my_set
output ---> {'love', 'happy', 'happiness', 'laughter'}

my_set.remove('happiness')
my_set
output ---> {'love', 'happy', 'laughter'}
```

In the first line, we create a set object with three elements and assign it to the variable `my_set`. Because `set objects are mutable`, we can `add` `'happy'` to the set and `remove` `'happiness'` from the set.

#### Dicts
```
my_dict = {"first_name": "Mattieu", "last_name": "Ricard"}
type(my_dict)
output ---> <class 'dict'>

my_dict["location"] = "Nepal"
my_dict
output ---> {'first_name': 'Mattieu', 'last_name': 'Ricard', 'location': 'Nepal'}

del my_dict['location']
my_dict
output ---> {'first_name': 'Mattieu', 'last_name': 'Ricard'}
```

On line one, we create a `dict` object that has `two key-value pairs`. Then, because `dict objects are mutable`, we add key-value pair `"location": "Nepal"`. Last, we delete that same key-value pair.

Mutable objects work great when you know you will likely need to change the size of the object as you use and interact with it. `Changing mutable objects is cheap` (because you don't have to copy all existing elements to a new object).

#### Aliasing with Mutable Objects
Below, I'm going to walk through what happens when you **alias** a mutable object. In Python, aliasing happens whenever a variable's value is assigned to another variable because variables are just names that store references to values.

Let me illustrate this with a helpful code visualizer tool called [Python Tutor](http://www.pythontutor.com/):

![](https://raw.githubusercontent.com/jmmiddour/CSPT19/main/1.1_Computer_Science_Fundamentals/images/1.1.3_fig1.png?token=APLSS6JKLYCA62S5K4QEGVDANAQQC)

On line 1, we instantiate a new list object with three elements (`1`, `2`, and `3`). The name `my_list_orig` is the variable that we assign the new list to.

![](https://raw.githubusercontent.com/jmmiddour/CSPT19/main/1.1_Computer_Science_Fundamentals/images/1.1.3_fig2.png?token=APLSS6MEUOGTWURACUSQYDLANAQVW)

Then, on line 2, we create an alias of `my_list_orig` by pointing `my_list_alias` to whatever object `my_list_orig` is pointing at. Notice in the image above that there is still only one list object. However, there are two variables in the global frame, and they are both pointing to the same object.

![](https://raw.githubusercontent.com/jmmiddour/CSPT19/main/1.1_Computer_Science_Fundamentals/images/1.1.3_fig3.png?token=APLSS6IUL4RGRBEYU7IXZCDANAQ4O)

On line 3, we append a new element to `my_list_orig`. Notice that, because both variables are referencing the same object, even though we appended to `my_list_orig`, we also modified `my_list_alias`.

![](https://raw.githubusercontent.com/jmmiddour/CSPT19/main/1.1_Computer_Science_Fundamentals/images/1.1.3_fig4.png?token=APLSS6OPE5T22XMTZIX4N5DANARDK)

On line 4, we `removed` the element `1` from `my_list_orig`. Notice, just like when we added to the list, `my_list_alias` is also affected.

*This behavior is something you need to be aware of if you ever use aliasing with mutable objects in your code.*

#### Immutable Objects
An immutable object is an object whose value cannot be changed after it is created. `Immutable` means `not changeable`. Anytime you try to update the value of an immutable object, `a new object is created instead`.

The following types are immutable:

- Numbers (int, float, complex)
- Strings
- Bytes
- Booleans
- Tuples

Immutable objects are useful when you want to make sure that the object you created will always maintain the same value. `Immutable objects are more expensive to change` (in terms of time and space complexity) because `changing the object requires making a copy` of the existing object.

Let's look at a few examples:

#### Numbers
```
my_int = 1
id(my_int)
output ---> 4513307280

type(my_int)
output ---> <class 'int'>

my_int
output ---> 1

my_int = 2
id(my_int)
output ---> 4513307312

type(my_int)
output ---> <class 'int'>

my_int
output ---> 2
```

In the code above, the first line creates a new `int` object, and the variable `my_int` now points at that object. You can see that this object has `int` for its `type`, `4513307280` for its `identity` (location in memory), and `1` for its `value`.

Then, we assign `2` to `my_int` which creates a whole new object and assigns it to the variable `my_int`. This object has `int` for its `type`, `4513307312` for its `identity` (which you can see is different from the first object), and `2` for its `value`.

#### Strings
Let's look at how string concatenation works in Python. Remember that str objects are immutable.

```
my_str = 'a'
type(my_str)
output ---> <class 'str'>

id(my_str)
output ---> 140716674193840

my_str
output ---> 'a'

my_str += 'b'
type(my_str)
output ---> <class 'str'>

id(my_str)
output ---> 140716674658992

my_str
output ---> 'ab'
```

So, on line 1, we create a string object with the value `'a'` and assign it to the variable `my_str`. We verify that the object is of `type str`, we print its `identity (140716674193840)` and print its `value`.

Then, we concatenate `'b'` onto the existing string with the line `my_str += 'b'`. Now, because string objects are immutable, we cannot change a string object's value after it has been created. To `concatenate`, we create a new string object and assign the value `'ab'` to that object.

This behavior in Python is vital to be aware of when working with string concatenation. If you have to add and remove frequently from a string, this will be inefficient if you work with string objects directly.

#### Tuples
Tuples are an `immutable container of names`, where each name has an unchangeable (immutable) binding to an object in memory. You cannot change the bindings of the names to the objects.

>>> my_tuple = ('love', [1,2,3], True)
>>> my_tuple[0]
'love'
>>> my_tuple[0] = 'laughter'
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
Here we created a tuple using ( and ) to denote the tuple literal syntax. Just like a list, tuples can contain elements of any type. Above, we've included a string, a list, and a boolean as our tuple elements. We are proving the tuple object's immutability by showing the error that occurs when trying to assign a new item to a position in the tuple.

One thing that often causes confusion surrounding the immutability of tuples in Python is demonstrated by the following behavior:

>>> my_tuple[1] = [4,5,6]
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> id(my_tuple[1])
140716674620864
>>> my_tuple[1][0] = 4
>>> my_tuple[1][1] = 5
>>> my_tuple[1][2] = 6
>>> my_tuple[1]
[4, 5, 6]
>>> my_tuple
('love', [4, 5, 6], True)
>>> id(my_tuple[1])
140716674620864
>>>
Notice that we cannot create a new list object and bind it to the name at position 1 of our tuple. This is demonstrated when my_tuple[1] = [4,5,6] raises a TypeError. However, we can assign new objects to the list that is at position 1 of our tuple? Why is that? Well, what do we know about lists in Python? Lists are mutable objects. So, we can modify a list without creating a new object. So, when we are modifying the list directly (instead of assigning a new object), it doesn't affect our tuple's immutability. Notice that the identity (140716674620864) of the list at my_tuple[1] doesn't change after replacing its three elements with 4, 5, and 6.

Passing Objects to Functions
Mutable and immutable objects are not treated the same when they are passed as arguments to functions. When mutable objects are passed into a function, they are passed by reference. So, suppose you change the mutable object that was passed in as an argument. In that case, you are changing the original object as well.

Mutable Objects as Arguments
>>> my_list = [1,2,3]
>>> def append_num_to_list(lst, num):
... lst.append(num)
... 
>>> append_num_to_list(my_list, 4)
>>> my_list
[1, 2, 3, 4]
>>>
https://tk-assets.lambdaschool.com/5528e90f-2784-4199-b520-a4d03adccbbc_mutable-object-passed-as-argument-to-function.gif

Notice that when append_num_to_list is called and my_list is passed in as an argument. When my_list is bound to lst in that stack frame, lst points to the original my_list in memory. The function call did not create a copy of my_list. This behavior is because lists are mutable objects in Python.

Immutable Objects as Arguments
Next, let's see how Python behaves when we pass an immutable object as an argument to a function:

>>> my_string = "I am an immutable object."
>>> def concatenate_string_to_string(orig_string, string_to_add):
... return orig_string + string_to_add
... 
>>> concatenate_string_to_string(my_string, " I hope!")
'I am an immutable object. I hope!'
>>> my_string
'I am an immutable object.'
>>>
https://tk-assets.lambdaschool.com/3e6a1461-9853-4494-8c17-33919e641eb0_immutable-object-passed-argument-to-function.gif

Notice when an immutable object is passed into a function, the object is copied and bound to the parameter name. In the example above, when my_string is passed into concatenate_string_to_string, my_string is copied to a new object bound to the name orig_string.

Challenge
