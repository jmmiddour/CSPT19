# CSPT19 Sprint 1 - Computer Science Fundamentals 

## Module 3 - Space and Time Compleity

* [Slides for the Lecture](https://docs.google.com/presentation/d/181UJho38-XTZco3iWbivs7uwVqDkdpTDyUi4YS1qaFQ/edit#slide=id.gaa7040cf82_0_29)

* [Lecture with Mari Batilando]()

* Always take into account the worse case scenario when calculating time and space complexity.

### Constant Time and Space:
* The runtime/space of our function doesn't change with respect to our input.

* It stays constant.

* Writen as `O(1)`

* *Example*: **Time:** *O(1)* <---> **Space:** *O(1)*
    ```
    def doComplicatedFunction(a, b, c):
        some_val = b + c * 12345        # T: 1, S: 1
        another_val = a + 6789          # T: 1, S: 1
        return some_val + another_val
    ```

### Linear Time and Space

* The runtime/space of our function increases linearly as our input size grows.

* Writen as `O(n)`.
    - `n` is the length of some list in time and space.
    
* *Example 1*: **Time:** *O(n)* <---> **Space:** *O(1)*
    ```
    def find_index(target, some_list):
        for (item, index) in enumerate(some_list):  # T: n, S: 1
            if item == target:                      # T: 1, S: 1
                return index                        # T: 1, S: 1
        return -1
    ```
  
* *Example 2*: **Time:** *O(n)* <---> **Space:** *O(n)*
    ```
    def do_things(some_list):
        another_list = []               # T: 1, S: n
        
        for item in some_list:          # T: n, S: 1
            another_list.append(item)   # T: 1, S: n
  
        return another_list
    ```
    
### Logarithmic Time and Space

* The runtime/space of our function grows logarithmically with respect to the input size.

* Writen as `O(log n)`.

* *Example*: **Time:** *O(log n)* <---> **Space:** *O(1)*
    ```
    # This is the algorithm for a binany search tree.
    def search(nums: List[int], target: int) --> int:
        min, max = 0, len(nums) - 1         # T: , S: 1
        
        while min <= max:                   # T: , S: 1
            mid = floor((min + max) / 2)    # T: , S: 1
  
            if nums[mid] == target:         # T: , S: 1
                return mid
            
            if nums[mid] < target:          # T: , S: 1
                min = mid + 1               # T: , S: 1
  
            else: 
                max = mid - 1               # T: , S: 1
  
        return -1
    ```

### Quadratic Time and Space

* The runtime/space of our function increases quadratically as our input size grows.

* Writen as **O(n<sup>c</sup>)** where **<sup>c</sup>** is a constant.

* A nested loop is usually a sign that something is in quadratic time.

* *Example*: **Time:** *O(n<sup>2</sup>)* <---> **Space:** *O(1)*
    ```
    def generate_all_pairs(some_list):
        for i in range(len(some_list)):             # T: n, S: 1
            for j in range(i + 1, len(some_list)):  # T: n, S: 1
                print((some_list[i], some_list[i])) # T: 1, S: 1
  
    generate_all_pairs([1, 2, 3])
    ```

### Exponential Time and Space

* The runtime/space of our function increases exponentially as our input size grows
